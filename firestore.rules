rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    function requesterUid() {
      return request.auth.uid;
    }
    function isOwner(doc) {
      return doc.data.members[requesterUid()] == 'owner';
    }
    function isEditor(doc) {
      return doc.data.members[requesterUid()] == 'editor';
    }
    function isViewer(doc) {
      return doc.data.members[requesterUid()] == 'viewer';
    }
    function isMemberRole(doc) {
      return doc.data.members[requesterUid()] in ['owner', 'editor', 'viewer'];
    }

    // Checklists collection
    match /checklists/{checklistId} {
      // Read a single checklist if the requester is a member (owner/editor/viewer)
      allow get: if isAuthenticated() && isMemberRole(resource);

      /*
       * List queries:
       * - IMPORTANT: queries that list checklists MUST include a constraint on memberIds
       *   (an array of userIds). For example:
       *     query(collection(db, 'checklists'), where('memberIds', 'array-contains', request.auth.uid))
       *
       * This rule enforces that list queries contain that constraint and avoids returning
       * documents broadly to unauthorized users.
       */
      allow list: if isAuthenticated()
                  // require the client to have included exactly one where clause on memberIds array-contains
                  && request.query.size() > 0
                  && request.query.where.size() == 1
                  && request.query.where[0].fieldPath == 'memberIds'
                  && request.query.where[0].op == 'array-contains'
                  && request.query.where[0].value == requesterUid();

      // Create: authenticated users can create checklists but must include themselves as owner
      allow create: if isAuthenticated()
                    && request.resource.data.keys().hasAll(['orgName', 'categories', 'members', 'memberIds'])
                    // requester must be present in members map as owner and in memberIds array
                    && request.resource.data.members[requesterUid()] == 'owner'
                    && requesterUid() in request.resource.data.memberIds
                    && request.resource.data.orgName is string
                    && request.resource.data.orgName.size() <= 200
                    && request.resource.data.categories is list;

      // Update: owners and editors can update. Only owners may change membership map or memberIds.
      allow update: if isAuthenticated()
                    && (
                      // owner and editor can update contents
                      (resource.data.members[requesterUid()] in ['owner', 'editor'])
                      // but if the update modifies the membership mapping or memberIds array,
                      // require that the requester is owner.
                      && (
                        (request.resource.data.members == resource.data.members && request.resource.data.memberIds == resource.data.memberIds)
                        || resource.data.members[requesterUid()] == 'owner'
                      )
                    )
                    // Basic validation to prevent mass field type changes
                    && (request.resource.data.orgName is string)
                    && (request.resource.data.categories is list);

      // Delete: only owner can delete the checklist
      allow delete: if isAuthenticated() && isOwner(resource);
    }

    // Users collection: public read, limited writes (only by the user themselves)
    match /users/{userId} {
      allow get: if isAuthenticated();
      allow list: if false; // disallow listing all users
      allow create, update: if isAuthenticated() && requesterUid() == userId
                            && (request.resource.data.displayName is string)
                            && request.resource.data.displayName.size() <= 200;
      allow delete: if false; // disallow deleting user documents via client
    }

    // Optionally protect any other collections you add (e.g., audit logs)
    match /{document=**} {
      // Default deny for everything else not explicitly allowed
      allow read, write: if false;
    }
  }
}